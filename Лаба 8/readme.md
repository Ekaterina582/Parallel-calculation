1. Постановка задачи
Цель работы — реализовать последовательный и параллельный (с использованием OpenMP) алгоритмы умножения матрицы на вектор, сравнить их производительность и проверить корректность результатов.
Основные задачи:
Генерация случайной квадратной матрицы и вектора заданного размера.
Реализация последовательного умножения.
Реализация параллельного умножения с использованием OpenMP.
Сравнение времени выполнения и точности результатов.

2. Выполнение работы
2.1. Генерация данных
Размер матрицы и вектора: 10000 x 10000.
Использован генератор случайных чисел std::mt19937 с равномерным распределением [0, 10].
2.2. Реализация алгоритмов
Последовательный алгоритм:
for (int i = 0; i < rows; ++i) {
    for (int j = 0; j < cols; ++j) {
        result[i] += a[i][j] * b[j];
    }
}
Параллельный алгоритм (OpenMP):
#pragma omp parallel for
for (int i = 0; i < rows; ++i) {
    double sum = 0.0;
    for (int j = 0; j < cols; ++j) {
        sum += a[i][j] * b[j];
    }
    result[i] = sum;
}
Оптимизации:
Локальная переменная sum для уменьшения конфликтов при записи.
Директива #pragma omp parallel for для распараллеливания внешнего цикла.
2.3. Проверка корректности
Результаты последовательного и параллельного умножения сравнивались с точностью 1e-6.
2.4. Сравнение производительности
Измерение времени выполнения с помощью std::chrono::high_resolution_clock.

3. Результаты
Метод /	Время выполнения (сек) /	Ускорение (Speedup)
Последовательный	/ 4.21 /	1x
Параллельный	/ 1.07 /	3.93x
Выводы:
Параллельная реализация с OpenMP показала ускорение в ~4 раза на 4-ядерном процессоре, что близко к линейному ускорению.
Результаты обоих алгоритмов идентичны (погрешность < 1e-6), что подтверждает корректность реализации.
Основные оптимизации:
Распараллеливание внешнего цикла.
Уменьшение ложного разделения кэша через локальную переменную sum.
Итог:
Параллельная реализация эффективно использует многопоточность и обеспечивает значительное ускорение при сохранении точности результатов.
