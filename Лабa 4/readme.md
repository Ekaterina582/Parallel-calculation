# Отчет по лабораторной работе  

**Тема:** Параллельное умножение матриц с использованием OpenMP  

---

## 1. Постановка задачи  

**Цель работы:**  
- Реализовать последовательное и параллельное умножение матриц.  
- Сравнить время выполнения обоих подходов.  
- Проверить корректность результатов параллельных вычислений.  

**Исходные данные:**  
- Две квадратные матрицы размера **500×500**, заполненные случайными числами.  
- Умножение выполняется двумя способами:  
  1. **Последовательный алгоритм** (один поток).  
  2. **Параллельный алгоритм** (OpenMP, несколько потоков).  

---

## 2. Описание выполнения работы  

### 2.1. Генерация матриц  
- Матрицы заполняются случайными числами в диапазоне `[8; 108]` с использованием генератора `std::mt19937`.  

### 2.2. Последовательное умножение  
- Реализовано через тройной вложенный цикл.  
- Время выполнения замеряется с помощью `std::chrono`.  

### 2.3. Параллельное умножение (OpenMP)  
- Внешний цикл распараллеливается с помощью `#pragma omp parallel for`.  
- Внутренний цикл векторизуется (`#pragma omp simd`).  
- Используется редукция для корректного суммирования.  

### 2.4. Проверка корректности  
- Результаты последовательного и параллельного умножения сравниваются поэлементно с допустимой погрешностью `1e-6`.  

---

## 3. Результаты и вывод  

### 3.1. Время выполнения  

| Метод                  | Время (сек) | Ускорение |  
|------------------------|-------------|-----------|  
| Последовательный       | 421         | 1x        |  
| Параллельный (OpenMP)  | 1.08        | **3.9x**  |  

### 3.2. Корректность результатов  
Результаты параллельного умножения **совпали** с последовательным (проверка пройдена).  

### 3.3. Вывод  
1. **Параллельный алгоритм работает быстрее** (в данном тесте — почти в 4 раза).  
2. **OpenMP эффективно ускоряет вычисления** за счет распараллеливания циклов.  
3. **Результаты корректны**, что подтверждает правильность реализации.  

--- 

**Итог:** Параллельное умножение матриц с OpenMP демонстрирует значительное ускорение при сохранении точности вычислений.  
