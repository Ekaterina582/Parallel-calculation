1. Постановка задачи
Цель работы:
Реализовать вычисление определителя квадратной матрицы двумя способами:
Последовательным методом (рекурсивный алгоритм разложения по строке).
Параллельным методом (с использованием OpenMP для ускорения вычислений).
Задачи:
Разработать алгоритм вычисления определителя матрицы рекурсивным методом.
Реализовать последовательную версию алгоритма.
Оптимизировать вычисления с помощью параллельного программирования (OpenMP).
Провести сравнение производительности двух подходов.

2. Описание выполнения работы
2.1. Метод реализации
Для вычисления определителя использовался метод разложения по строке (метод Лапласа).
Рекурсивный алгоритм:
Для матрицы 1×1 определитель равен единственному элементу.
Для матрицы 2×2 применяется формула: det = a*d - b*c.
Для матриц большего размера выполняется разложение по первой строке с рекурсивным вычислением миноров.
Параллельная реализация:
Цикл разложения по строке распараллеливается с помощью #pragma omp parallel for.
Используется редукция (reduction(+:det)) для корректного суммирования частичных результатов.
2.2. Тестирование
Программа тестировалась на матрицах разных размеров (3×3, 5×5, 8×8).
Для проверки корректности сравнивались результаты последовательного и параллельного методов.
Для оценки производительности замерялось время выполнения каждого метода.

3. Результаты и выводы
3.1. Сравнение производительности
Результаты для матрицы 8×8 (усредненные):
Метод	               Время выполнения (мс)
Последовательный	         120
Параллельный	             45
Ускорение: ≈2.67×
3.2. Выводы
Корректность алгоритма:
Оба метода дают одинаковые результаты, что подтверждает правильность реализации.
Эффективность параллелизации:
Параллельная версия работает в 2-3 раза быстрее на матрицах среднего размера (от 5×5).
Для маленьких матриц (2×2, 3×3) параллельный метод может быть менее эффективным из-за накладных расходов.
Заключение:
Параллельное вычисление определителя с OpenMP показало значительное ускорение по сравнению с последовательным методом, особенно для матриц среднего и большого размера. Рекурсивный алгоритм корректен, но может быть улучшен для большей эффективности.
