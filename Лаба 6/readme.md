1. Постановка задачи
Цель работы — сравнить производительность последовательного и параллельного вычисления суммы элементов большого массива с использованием технологии OpenMP.
Задачи:
Сгенерировать массив случайных чисел большого размера.
Реализовать последовательное вычисление суммы.
Реализовать параллельное вычисление суммы с использованием OpenMP.
Сравнить время выполнения обоих подходов и оценить эффективность распараллеливания.

2. Описание выполнения работы
2.1. Генерация массива
Для тестирования был создан массив из 100 000 000 случайных целых чисел в диапазоне от 1 до 100. Генерация выполнена с использованием стандартной библиотеки <random> в C++.
2.2. Последовательное вычисление суммы
Функция sum() проходит по всем элементам массива в одном потоке и накапливает сумму. Время выполнения замеряется с помощью <chrono>.
2.3. Параллельное вычисление суммы (OpenMP)
Функция sum_parallel() использует директиву OpenMP:
#pragma omp parallel for reduction(+:total)
Это позволяет автоматически разделить цикл между несколькими потоками, а reduction обеспечивает корректное суммирование результатов из разных потоков.
2.4. Сравнение результатов
После вычислений программа выводит:
Сумму, полученную последовательным и параллельным методами (должны совпадать).
Время выполнения каждого метода.
Коэффициент ускорения (Ускорение = Время последовательного / Время параллельного).

4. Результаты и выводы
3.1. Полученные данные (пример)
Метод	/ Сумма	/ Время (сек) /	Ускорение
Последовательный	/ 5 050 043 212 /	0.25 /	—
Параллельный (4 потока)	/ 5 050 043 212 /	0.07	/ 3.57x
3.2. Анализ результатов
Корректность: Оба метода дали одинаковый результат, что подтверждает правильность реализации.
Производительность: Параллельная версия работает быстрее, ускорение зависит от количества ядер CPU.
Эффективность OpenMP: Использование #pragma omp parallel for с reduction значительно упрощает распараллеливание без явного управления потоками.
3.3. Вывод:
Параллельное вычисление суммы с OpenMP ускоряет обработку больших массивов в несколько раз. Однако эффективность зависит от:
Размера данных (на маленьких массивах накладные расходы могут нивелировать выгоду).
Количества доступных ядер процессора.
Оптимизации кода (например, избегание ложного разделения кэша).
Таким образом, OpenMP — мощный инструмент для ускорения вычислений в C++ при работе с большими объемами данных.
