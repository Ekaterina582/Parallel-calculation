1. Постановка задачи
Цель работы — сравнить три подхода к синхронизации доступа к общему ресурсу в многопоточной среде:
Без синхронизации (риск состояния гонки, race condition).
С использованием мьютексов (классическая блокировка).
С использованием атомарных операций (эффективная альтернатива блокировкам).
Необходимо:
Реализовать программу, демонстрирующую каждый подход.
Измерить время выполнения и проверить корректность результата.
Сравнить производительность и надежность методов.

2. Выполнение работы
2.1. Методы синхронизации
1) Без синхронизации
Потоки напрямую изменяют общую переменную (shared_value_no_sync++).
Проблема: Возникает race condition, итоговое значение меньше ожидаемого.
2) С мьютексом
Перед изменением переменной поток захватывает мьютекс (std::lock_guard).
Плюсы: Гарантированная корректность.
Минусы: Замедление из-за блокировок.
3) С атомарными операциями
Используется std::atomic<int>, операции выполняются без явных блокировок.
Плюсы: Корректность + высокая скорость.
2.2. Результаты тестирования
Программа запускалась с параметрами:
Количество потоков: 10
Итераций на поток: 1 000 000
Метод	/ Итоговое значение /	Время выполнения (сек)
Без синхронизации /	4 658 321 /	0.123
С мьютексом	/ 10 000 000 /	0.876
С атомарными операциями	/ 10 000 000 /	0.234
3. Выводы
Без синхронизации:
Самая высокая скорость, но результат некорректен из-за race condition.
Не подходит для реальных задач.
С мьютексом:
Корректный результат, но значительные накладные расходы на блокировки.
Скорость в 3–4 раза ниже, чем у атомарных операций.
С атoмарными операциями:
Корректный результат + максимальная производительность.
Оптимальный выбор для простых операций (инкремент, декремент и т. д.).
Итог: Атомарные операции обеспечивают лучший баланс между корректностью и производительностью.
