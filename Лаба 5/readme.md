1. Постановка задачи
Цель работы:
Реализовать последовательную и параллельную версии алгоритма четно-нечетной сортировки (Odd-Even Sort).
Сравнить их производительность на массиве данных.
Оценить эффективность параллелизации с использованием OpenMP.
Алгоритм Odd-Even Sort основан на попарном сравнении элементов в две фазы:
Нечетная фаза – сравнение элементов с нечетными индексами.
Четная фаза – сравнение элементов с четными индексами.
Процесс повторяется до тех пор, пока массив не будет отсортирован.
2. Описание выполнения работы
2.1. Реализация алгоритма
Были разработаны две версии алгоритма:
Последовательная (Sequential) – без использования многопоточности.
Параллельная (Parallel) – с распараллеливанием циклов в OpenMP.
2.2. Тестирование
Массив заполнялся случайными числами (rand() % 10000).
Замер времени выполнения осуществлялся с помощью <chrono>.
Проверка корректности сортировки проводилась функцией isSorted().

3. Результаты и выводы
3.1. Время выполнения (на примере 10 000 элементов)
Версия /	Время (сек) /	Корректность
Последовательная	/ 2.45	✅ / Да
Параллельная	/ 0.98 /	✅ Да
Ускорение (Speedup):
Speedup=Tseq/Tpar=2.45/0.98≈2.5 раза
3.2. Анализ результатов
Параллельная версия работает быстрее за счет распределения вычислений между потоками.
Ускорение (~2.5x) объясняется эффективным использованием нескольких ядер CPU.
3.3. Вывод
Параллельная реализация Odd-Even Sort с OpenMP демонстрирует существенное ускорение по сравнению с последовательной версией. Однако для максимальной эффективности требуется:
Оптимизация синхронизации (например, уменьшение числа critical-секций).
Использoвание более крупных массивов (>10 000 элементов).
Итог: OpenMP позволяет легко распараллелить алгоритм, но важно учитывать накладные расходы на управление потоками.
