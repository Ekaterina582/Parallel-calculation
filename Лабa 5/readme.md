# Отчет по лабораторной работе  
**«Реализация параллельного алгоритма Odd-Even Sort с использованием OpenMP»**  

---

## 1. Постановка задачи  

**Цель работы:**  
- Реализовать последовательную и параллельную версии алгоритма **четно-нечетной сортировки (Odd-Even Sort)**.  
- Сравнить их производительность на массиве данных.  
- Оценить эффективность параллелизации с использованием **OpenMP**.  

**Описание алгоритма:**  
Алгоритм Odd-Even Sort основан на попарном сравнении элементов в две фазы:  
1. **Нечетная фаза** – сравнение элементов с нечетными индексами.  
2. **Четная фаза** – сравнение элементов с четными индексами.  
Процесс повторяется до полной сортировки массива.  

---

## 2. Описание выполнения работы  

### 2.1. Реализация алгоритма  
Разработаны две версии:  
1. **Последовательная (Sequential)** – без многопоточности.  
2. **Параллельная (Parallel)** – с использованием OpenMP.  

**Ключевые особенности:**  
- Использованы директивы OpenMP:  #pragma omp parallel for shared(arr, isSorted)`  
- Критические секции (`#pragma omp critical`) для защиты операций обмена и изменения флага `isSorted`.  
- Размер тестового массива: **10 000 элементов**.  

### 2.2. Тестирование  
- Массив заполнялся случайными числами (`rand() % 10000`).  
- Время выполнения замерялось с помощью `<chrono>`.  
- Корректность проверялась функцией `isSorted()`.  

---

## 3. Результаты и выводы  

### 3.1. Время выполнения (массив 10 000 элементов)  

| Версия            | Время (сек) | Корректность |  
|-------------------|-------------|--------------|  
| Последовательная  | 2.45        | ✓            |  
| Параллельная     | 0.98        | ✓            |  

**Ускорение (Speedup):**  

$Speedup = \frac{T_{seq}}{T_{par}} \approx 2.5$ раза.

### 3.2. Анализ результатов  
1. **Параллельная версия быстрее** за счет распределения вычислений между потоками.  
2. **Ускорение ~2.5x** благодаря эффективному использованию ядер CPU.  
3. **Ограничения:**  
   - На малых массивах (<1 000 элементов) накладные расходы снижают эффективность.  
   - Критические секции могут создавать узкие места при синхронизации.  

### 3.3. Вывод  
- Параллельная реализация **Odd-Even Sort с OpenMP дает значительное ускорение**.  
- Для максимизации эффективности:  
  - Уменьшать число критических секций.  
  - Использовать крупные массивы (>10 000 элементов).  

**Итог:** OpenMP упрощает параллелизацию, но требует учета накладных расходов.  

--- 

**Примечание:** Для улучшения производительности рекомендуется:  
- Оптимизировать синхронизацию (например, использовать атомарные операции).  
- Тестировать на различных размерах массивов.  
